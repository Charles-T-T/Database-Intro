# 数据库系统概论

[TOC]

# 第一章 绪论

## 什么是数据库？

- 本质是数据的集合

- **长期存储** 在计算机内 **有组织** 、 **可共享** 的大量 **数据的集合**

- 按一定的 **数据模型** 组织、描述和存储，具有较小的 **数据冗余** 、较高的 **数据独立性** 和 **可扩展性** ，并可为各种用户 **共享**


### 数据冗余

- 数据冗余指 **同一份数据在多个不同地方存储** ，比如我们的基本信息在学校、医院、公安、银行等多个信息系统存储，甚至同一个信息系统（比如微人大）中也会多次存储同一个信息（姓名）。

- 数据冗余可能导致数据的不一致，存储空间的浪费，更新操作复杂等问题；但冗余也可以便利查询操作、增加安全性。

## 数据模型

- 数据模型是对现实世界数据特征的抽象，是 **现实世界的模拟**

- 数据模型是用来描述数据、组织数据和对数据进行操作的

- 数据模型是数据库系统的 **核心和基础**

  > XX数据库，一般“XX”都是数据模型，比如层次/网状/关系/KV/图 等等
  >
  > 近年来， **多模数据库** （multi-model database system）逐渐成为研究热点，如OrientDB，ArangoDB

- 数据建模的过程： **两步抽象** 
  - 将现实世界中的客观对象抽象为 **概念模型** （将现实世界抽象为信息世界）
  - 将概念模型转换为某一数据库管理系统（DBMS）支持的 **数据模型** （将信息世界转换为机器世界）

### 概念模型

- 信息世界中的基本概念
- 概念模型的一种表示方法： **实体-联系方法（Entity-Relationship Approach，E-R方法/E-R模型）** 
  - 实体（entity）：客观存在并可相互区别的事物称为实体
  - 属性（attribute）：实体所具有的某一特性称为属性
  - **码（key）：唯一标识实体的属性集称为码** 
  - 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体称为实体型
  - 实体集（entity set）：同一类型实体的集合称为实体集
  - 联系（relationship）：现实世界中事物内部以及事物之间的联系在信息世界，实体之间的联系有一对一、一对多和多对多等多种类型

<img src="./pics/image-20240923171019684.png" alt="image-20240923171019684" width="700" />

- 抽象了学校中的学生和课程两个客观事物：学生实体和课程实体

- 抽象了现实世界中事物之间的联系：
  - 一门课程可以有多名学生选修，一个学生可以选修多门课程
  - 用课程实体与学生实体多对多（m:n）联系来描述

### 数据模型的三要素

#### 数据结构

对系统静态特性的描述。

#### 数据操作

对数据库中各种对象（型）的实例（值）允许执行的 **操作的集合** ，包括 **操作** 及有关的 **操作规则** 。

对系统动态特性的描述。

#### 数据完整性约束 :star2: 

- 一组完整性规则

- 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则

- 限定符合数据模型的数据库状态及状态的变化，以保证数据的正确、有效和相容

  > *e.g.* 一个完整性规则的例子：
  >
  > 学生数据中，年龄必须大于0，所学专业必须真实存在，学号应该是10位数且以年份开头

### 层次模型

- 实体用记录表示

- 实体的属性对应记录的数据项（或字段）

- 实体之间的联系转换成记录之间的两两联系

- 数据结构的单位是基本层次联系

  - 是指两个记录以及它们之间的一对多（包括一对一）的联系

    <img src="./pics/image-20240923172408131.png" alt="image-20240923172408131" width="500" />

- 用 **树形结构** 来表示各类实体及实体之间的联系

> 层次模型是数据库系统中最早出现的数据模型。
>
> 典型代表是IBM公司的IMS（Information Management System）。

- 优点

  - 数据结构比较简单清晰

  - 查询效率高

    > 层次模型中记录之间的联系用有向边表示，就是记录之间的存储距离。

  - 提供了良好完整性约束

- 缺点

  - 现实中很多联系是非层次性的

  - 一个节点具有多个双亲节点，只能通过冗余数据或创建非自然的数据结构来解决

  - 对 **插入** 和 **删除** 操作的限制多， **应用程序的编写比较复杂** 

  - **查询子女节点必须通过双亲节点** 

    > 层次模型中，只允许一个节点无双亲节点——根节点。

  - 层次命令趋于程序化（必须按层次、顺序操作）

例如，在企业管理系统中，假如每个公司都表示为一个独立的树形结构，而多个公司没有直接联系，这样的结构就可以通过一个虚拟的“超级根节点”来统一表示：

```bash
超级公司（Super Company）
   └── 公司A（Company A）
       └── 部门1
           └── 员工1
       └── 部门2
   └── 公司B（Company B）
       └── 部门1
           └── 员工2
```

### 网状模型

满足以下两个条件的基本层次联系集合：

- 允许一个以上的节点无双亲
- 一个节点可以有多个双亲

网状模型的表示方法：

- 实体性：用记录类型描述，每个节点表示一个记录类型（实体）
- 属性：用字段描述，每个记录类型可包含若干个字段
- 联系：用节点之间的连线表示记录类型（实体）之间的 **一对多的父子联系** 

网状数据库系统（如DBTG）对数据操纵加限制，提供了一定的完整性约束。

- **码：唯一表示记录的数据项的集合**
- 一个联系中，双亲记录与子女记录之间是一对多的联系
- 支持双亲记录和子女记录之间的某些约束条件

优点：

- 能够更直接地描述现实世界，如一个节点可以有多个双亲，节点之间可以有多种联系
- 具有良好的性能，存取效率较高

缺点：

- **结构比较复杂，** 随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握

- DDL、DML语言复杂，要嵌入到某一种高级语言中，用户不容易使用

  > **DDL（数据定义语言）**：用于定义网状数据库的结构，包括记录类型、关系和子集等。
  >
  > **DML（数据操作语言）**：用于操作数据库中的数据，包括插入、更新、删除和查询记录及关系。

- 记录之间联系是通过存取路径实现， **用户必须了解系统结构的细节** 

  > 之前提到，网状数据库中的数据通过“边”相互连接，从而形成一个网状结构；要访问某个记录，必须要从已知的记录开始，沿着定义好的路径遍历关系，直到找到目标记录。

### 关系模型 :star2: 

> :calendar: 1970年，美国IBM公司San Jose研究室的研究员E.F.Codd首次提出了数据库系统的关系模型。
>
> :desktop_computer: 1980年代以来，计算机厂商推出的数据库管理系统几乎都支持关系模型。

#### 数据结构

- 从用户观点看，关系模型由一组关系构成

- 每个关系的数据结构是一张 **规范化** 的 **二维表** 

  ![image-20240923220319947](./pics/image-20240923220319947.png)

几个基本概念：

- 关系（relation）：一个关系对应通常说的 **一张表**

- 元组（tuple）：表中的 **一行** 即为一个元组

- 属性（attribute）：表中的 **一列** 即为一个属性，给每个属性起的名字即为属性名（列名）

- **码（key）** ：又称码键或键。表中的 **某一个/一组属性** ，它的值可以 **唯一确定一个元组** 

- 域（domain）：是一组具有相同类型的值的集合。属性的取值范围来自某个域

- 分量：元组中的一个属性值

- 关系模式：对关系的描述，形如 *关系名（属性1，属性2，...，属性n）*

  > *e.g.* 学生（学号，姓名，性别，出生日期，主修专业）
  >
  > 其中学号是码

关系必须是 **规范的** ，满足一定的规范条件。

最基本的规范条件：关系的每一个分量必须是一个 **不可分** 的数据项， **不允许表中还有表** 

> *e.g.* 下表中的“联系方式”是可分的数据项， **不符合关系模型的要求** 
>
> ![image-20240923221337503](./pics/image-20240923221337503.png)

#### 数据操作

关系模型的数据操作是 **集合** 操作，操作对象和操作结果都是 **关系** 。 

操作主要有查询、插入、删除、更新。

#### 关系的完整约束性条件

- 实体完整性
- 参照完整性
- 用户定义的完整性

- [ ] TODO：在下一章展开

#### 优点

- 建立在 **严格的数学概念** 的基础上
- 概念单一
  - 实体和实体之间的联系都用关系来表示
  - 对数据的检索和更新结果也是关系
- 关系模型的存取路径对用户是 **隐蔽的** 
  - 具有更高的数据独立性，更好的安全保密性
  - **简化了程序员的工作** 和数据库开发建立的工作

#### 缺点

- 存取路径对用户隐蔽，查询效率往往不如层次模型和网状模型

  > **缺乏控制**：用户无法直接控制查询的执行计划和数据的存取路径，这可能导致某些性能优化的机会被错过。例如，在某些情况下，用户希望使用特定的索引或连接方式来提高查询效率，但数据库系统可能选择了次优的执行路径。
  >
  > **不适合极端优化需求**：在一些高性能计算或数据分析场景下，用户可能需要对数据访问进行非常细粒度的调优，隐蔽的存取路径限制了这种能力。

- 为提高性能，必须对用户的查询请求进行优化，增加了开发数据库的难度

### 数据库领域中不断涌现的数据模型

- 层次模型、网状模型
- 关系模型
- 面向对象数据模型、对象关系数据模型
- 半结构化的XML数据模型
- 新型数据模型
  - 键值对数据模型（Key-Value）
  - 文档数据模型
  - 图数据模型
  - 时序数据模型
  - 时空数据模型
  - 流数据模型
  - 多媒体数据模型
  - ...

# 第二章 关系数据库

## 数据结构

- 单一的数据结构——关系：现实世界的 **实体** 以及 **实体间的各种联系** 均用关系来表示
- 逻辑结构——二维表：从用户角度，关系模型中数据的逻辑结构是一张二维表
- 建立在 **集合代数** 的基础上

重温几个基本概念：

- 域（domain）：一组具有 **相同数据类型** 的值的 **集合** 

  > *e.g.* 整数；实数；介于某个取值范围的整数；长度小于25字节的 **变长字符串** 集合；{男，女}；...

- 笛卡尔积

  给定一组域 $D_1, D_2, ... , D_n,$ *允许其中某些域是相同的* ， $D_1, D_2, ... , D_n$ 的笛卡尔积为：

  $D_1 \times D_2 \times ... \times D_n = \{(d_1 ,d_2, ..., d_n)|d_i \in D_i, \ i = 1, 2, ..., n\}$ 

  - 所有域的所有取值的一个 **组合**
  - **不能重复**

- 元组（tuple）： **笛卡尔积中每一个元素** $(d_1, \ d_2, \ ..., \ d_n)$ 叫作一个 $n$ 元组（n-tuple）或简称 **元组** 

  > *e.g.* (张清玫，计算机科学与技术，李勇)、(张清玫，计算机科学与技术，刘晨)  等都是元组 

- 分量（Component）

  - 笛卡尔积元素 $(d_1, \ d_2, \ ..., \ d_n)$ 中的每一个值 $d_i$ 叫作一个 **分量** 
  
    > *e.g.* 张清玫、计算机科学与技术、李勇、刘晨等都是分量
  
- 基数（cardinal number）

  - 一个域允许的不同取值的个数
  - 若 $D_i \ (i=1, 2, ..., n)$ 为有限集，其基数为 $m_i \ (i = 1, 2, ..., n)$ ，则 $D_1 \times D_2 \times .. \times D_n$  的基数 $M$ 为： $M =  \prod_{i=1}^{n} m_i$  


数据库中，笛卡尔积可以表示为一张 **二维表** ，表中的 **每行对应一个元组，每列来自一个域** 。

## 关系

- 关系模型中 $D_1， D_2, ..., D_n$ 的笛卡尔积一般没有实际语义，只有某个真子集才有 **实际含义** 。

几个相关概念：

- 关系： $D_i \times D_2 \times ... \times D_n$ 的 **子集** 叫作在域 $D_1, D_2, ..., D_n$ 上的 **关系** ，表示为 $R(D_1, D_2, ..., D_n)$ 。其中，
  - $R$ ：关系名
  - $n$ ：关系的 **目** 或 **度** （degree）
  
- 元组：关系中的每个元素是关系中的元组，通常用 $t$ 表示

- 单元关系&二元关系
  - 当 $n = 1$ 时，称该关系为 **单元关系** （unary relation）或 **一元关系** 
  - 当 $n = 2$ 时，称该关系为 **二元关系** （binary relation）

- 关系的表示：关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域

- 属性

  - 关系中不同列可以对应相应的域

  - 为了加以区分，必须对每列起一个名字，成为属性（attribute）

  - $n$ 目关系必有 $n$ 个属性

    > *e.g.* **SMP(SUPER,  MAJOR, POSTGRADUATE)** 有3个属性，是一个3目关系；（张清玫，计算机科学与技术，李勇），（张清玫，信息管理与信息系统，刘晨），(刘逸，信息管理与信息系统，王敏) 是**SMP**关系的3个元组

- 三类关系

  - 基本关系（基本表或基表）： **实际存在**的表，是实际存储数据的逻辑表示
  - 查询表：查询执行产生的结果对应的**临时表** 
  - 视图表：由基本表或其他视图表导出的**虚表** ，不存储实际数据

- 基本关系的性质

  - 列是 **同质的** （homogeneous）

  - 不同的列可出自同一个域

    - 其中每一列称为一个属性
    - 不同的属性要给予不同的属性名

  - 列的顺序无所谓，可以任意交换

  - 任意两个元组的**码不能相同** 

  - 行的顺序无所谓，可以任意交换

  - 分量必须取原子值，即每一个分量都必须是**不可分的**数据项——这是规范条件中最基本的一条

    例如，下面的**POSTGRADUATE**是错误的分量，因其是可分的，其下存在小表。

    ![image-20241010085714860](./pics/image-20241010085714860.png)


## 关系模式

关系模式是型，关系是值。

关系模式是对关系的描述：
- 描述关系元组集合的**结构**
  - 属性构成
  - 属性来自的域
  - 属性与域之间的映象关系
- 描述关系的**完整性约束** 

关系模式可以形式化地表示为： $R(U, \ D, \ DOM, \ F)$ ，其中

- $R$ ：关系名
- $U$ ：组成该关系的属性名集合
- $D$ ： $U$ 中属性来自的域
- $DOM$ ：属性向域的映象集合
- $F$ ：属性间数据的依赖关系集合

例如， `导师` 和 `研究生` 出自同一个域：人，

- 取不同的属性名

- 在模式中定义属性向域的映象，即说明它们分别出自哪个域：

  **DOM(SUPERVISOR) = DOM(POSTGRADUATE) = PERSON**

关系模式通常可以简记为 $R(U)$ 或 $R(A_1, A_2, ..., A_n)$ 

- $R$ ：关系名
- $A_1, A_2, ..., A_n$ ：属性名
- 域名及属性向域的映象常常直接说明为属性的 **类型、长度** 

## 关系代数

### 传统的集合运算

### 专门的关系运算

#### 选择（selection）

- 选择又称为限制（restriction）
- 操作对象： **一个关系** 

#### 投影（projection）

#### 连接（join）

两种常用的连接运算：

- 等值连接（equijoin）

  > A，B可以不同，值相同即可（对比自然连接）

- 自然连接（natural join）

  > 没有条件，直接“合并同类列”

# 第三章 SQL语言

> 一条SQL语句以分号结尾

> VARCHAR：长度可变，根据实际数据而定
>
> CHAR：定长空间

 ![schema](./pics/schema)

`GROUP BY` :

![image-20241017103929570](./pics/image-20241017103929570.png)

```SQL
SELECT genre, AVG(budget)
FROM movies
GROUP BY genre;
```

`WHERE` 要在 `GROUP BY` 之前：

![group_where](./pics/group_where)

# 第四章 数据库安全性

遵纪守法。

## 存取控制

### 存取控制机制组成

- 定义用户权限，并将用户权限登记到**数据字典**中
  - 用户对某一数据对象的操作权力称为权限
  - DBMS提供适当的语言来定义用户权限，存放在数据字典中，称作安全规则或授权规则
- 合法权限检查
  - 用户发出存取数据库操作请求
  - DBMS查找数据字典，进行合法权限检查

**用户权限定义** 和 **合法权限检查机制** 一起组成了DBMS的存取控制子系统。

### 常用存取控制方法

- **自主存取控制** （Discretionary Access Control, DAC）
  - C2级
  - 用户对不同的数据对象有不同的存取权限
  - 不同的用户对同一对象有不同的权限
  - 用户可以将其拥有的存取权限转授给其他用户
- **强制存取控制** （Mandatory Access Control, MAC）
  - B1级
  - 每一个数据对象被标以一定的 **密级** 
  - 每一个用户也被授予某一个级别的 **许可证** 
  - 对于任意一个对象，只有具有合法许可证的用户才可以存取

### 自主存取控制方法

- 通过SQL的 `GRANT` 语句和 `REVOKE` 语句实现
- 用户权限组成
  - 数据库对象
  - 操作类型
- 定义用户存取权限：定义用户可以在哪些数据对象上进行哪些类型的操作
- 定义存取权限称为 **授权** 

### 授权：授予&收回

#### `GRANT` 

`GRANT` 语句的一般格式：

```SQL
GRANT <权限>[,<权限>]...
ON <对象类型><对象名>[,<对象类型><对象名>]...
TO <用户>[,<用户>]...
[WITH GRANT OPTION];
```

语义：将对指定操作对象的指定操作权限授予指定的用户。

- 发出 `GRANT` 
  - 数据库管理员（DBA）
  - 数据库对象创建者（即属主owner）
  - 拥有该权限的用户
- 接受权限的用户
  - 一个或多个具体用户
  - `PUBLIC` （即全体用户）

`WITH GRANT OPTION` 语句

- 指定：可以 **再授予**
- 未指定： **不能传播** 

> :warning: 不允许循环授权
>
> <img src="./pics/grant_option_no_loop" alt="grant_option_no_loop" width="350;" /> 

- [ ] TODO：例子

#### `REVOKE` 

授予的权限可以有数据库管理员或其他授权者用 `REVOKE` 语句收回。

`REVOKE` 语句的一般格式为：

```SQL
REVOKE <权限>[,<权限>]...
ON <对象类型><对象名>[,<对象类型><对象名>]...
FROM <用户>[,<用户>]...[CASCADE|RESTRICT];
```

- 指定了 `CASCADE` ，则 **级联收回** 授予的权限
- 指定了 `RESTRICT` ，如果转授了权限，则不能收回
- 默认值为 `RESTRICT` 

- [ ] TODO：例子

### 数据库角色

角色：被命名的一组数据库操作相关的权限

- 角色是 **权限的集合** 
- 可以为一组具有相同权限的用户创建一个角色
- 可以简化授权的过程

角色的创建：

```sql
CREATE ROLE <角色名>
```

给角色授权：

```SQL
GRANT <权限>[,<权限>]...
ON <对象类型>对象名
TO <角色>[,<角色>]...
```

将一个角色授予其他角色或用户：

```SQL
GRANT <角色1>[,<角色2>]...
TO <角色3>[,<用户1>]...
[WITH ADMIN OPTION]
```

:point_up_2: 该语句把角色授予某用户，或授予另一个角色；授予这是角色的创建者或拥有在这个角色上的 `ADMIN OPTION` 权限者；指定了`WITH ADMIN OPTION` 可以把权限授予其他角色。

一个角色的权限：直接授予这个角色的全部i权限 加上 其他角色授予这个角色的全部权限。

角色权限的收回：

```SQL
REVOKE <权限>[,<权限>]...
ON <对象类型><对象名>
FROM <角色>[,<角色>]...
```

用户可以回收角色的权限，从而修改角色拥有的权限。

`REVOKE` 的执行者是：角色的创建者；拥有在这（些）个角色上的 `WITH ADMIN OPTION` 权限者。



# 第五章 数据库完整性

为了维护数据库的完整性，RDBMS必须实现：

1. 提供定义完整性约束的机制

2. 提供完整性约束的方法

3. 提供完整性违约处理的方法

   - RDBMS若发现用户的操作违背了完整性约束，就采取一定的动作

     - 拒绝（NO ACTION）执行此操作

     - 级联（CASCADE）执行其他操作

## 实体完整性

关系模型的实体完整性在 `CREATE TABLE` 中用 `PRIMARY KEY` 定义。

对单属性构成的码有两种说明方法：

- 定义为列级约束
- 定义为表级约束

对多个属性构成的码只有一种说明方法：

- 定义为表级约束

**实体完整性检查和违约处理：**

- 检查主码值是否唯一，如果不唯一则拒绝插入或修改
- 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改

## 参照完整性

关系模型的参照完整性在 `CREATE TABLE` 中用 `FOREIGN KEY` 短语定义哪些列为外码，用 `REFERENCES` 短语指明这些外码参照哪些表的主码。

**参照完整性检查和违约处理**

| 被参照表（如Student） | 参照表（如SC） | 违约处理 |
| :--------------------: | :--------------: | :--------: |
| 可能破坏参照完整性 :arrow_left: | :arrow_left: 插入元组 | 拒绝 |
| 可能破坏参照完整性 :arrow_left: | :arrow_left: 修改外码值 | 拒绝 |
| 删除元组 :arrow_right: | :arrow_right: 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |
| 修改主码值 :arrow_right: | :arrow_right: 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |

## 用户定义的完整性

### 属性上的约束

在 `CREATE TABLE` 中定义属性的同时，可以根据应用要求定义属性上的约束，即属性值限制，包括

- 列值非空（ `NOT NULL` ）
- 列值唯一（ `UNIQUE` ）
- 检查列值是否满足一个条件表达式（ `CHECK` 短语）

### 元组上的约束

与属性上的约束类似，在 `CREATE TABLE` 语句中可以用 `CHECK` 短语定义元组上的约束，即元组级的限制。同属性值限制相比，元组级的限制可以设置不同属性之间取值的相互约束。

> *e.g.* 增加约束：当学生的性别是“男”时，其姓名（ `Sname` ）不能以 'Ms.' 打头
>
> ```sql
> CREATE TABLE Student
> 	(Sno CHAR(8),
>      Sname CHAR(20) NOT NULL,
>      Ssex CHAR(6),
>      Sbirthdate DATE,
>      Smajor VARCHAR(40),
>      PRIMARY KEY (Sno),
>      CHECK (Ssex='女' OR Sname NOT LIKE 'MS.%')
>     ); /*定义了元组中Sname和Ssex两个属性之间的约束条件*/
> ```

元组上约束的检查和违约处理：不满足则拒绝操作执行。

## 完整性约束命名子句

格式： `CONSTRAINT <完整性约束名> <完整性约束>` 

其中， `<完整性约束>` 包括 `NOT NULL` , `UNIQUE` , `PRIMARY KEY` , `FOREIGN KEY` , `CHECK` 短语等。

> *e.g.* 
>
> ```sql
> CREATE TABLE Student
>     (Sno CHAR(8)
>      CONSTRAINT Cl CHECK(Sno BETWEEN '10000000' AND '299999991'),
>      Sname CHAR(20)
>      CONSTRAINT C2 NOT NULL,
>      Sbirthdate Date
>      CONSTRAINT C3 CHECK( Sbirthdate >'1980-1-1'),
>      Ssex CHAR(6)
>      CONSTRAINT C4 CHECK(Ssex IN(男，女)),
>      Smajor VARCHAR(40),
>      CONSTRAINT StudentKey PRIMARY KEY(Sno)
>     );
> ```

:warning: 注意，记得为每个完整性约束起名。

